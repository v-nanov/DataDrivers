// Generated by the Protocol Buffers 3.2 compiler.  DO NOT EDIT!
// Source file "DataModel.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct DataModelRoot {
  public static let `default` = DataModelRoot()
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(registry: extensionRegistry)
  }
  public func registerAllExtensions(registry: ExtensionRegistry) {
  }
}

final public class BookInfo : GeneratedMessage {

  public static func == (lhs: BookInfo, rhs: BookInfo) -> Bool {
    if (lhs === rhs) {
      return true
    }
    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
    fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
    fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
    fieldCheck = fieldCheck && (lhs.hasAuthor == rhs.hasAuthor) && (!lhs.hasAuthor || lhs.author == rhs.author)
    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
    return fieldCheck
  }

  public fileprivate(set) var id:Int64 = Int64(0)
  public fileprivate(set) var hasId:Bool = false

  public fileprivate(set) var title:String = ""
  public fileprivate(set) var hasTitle:Bool = false

  public fileprivate(set) var author:String = ""
  public fileprivate(set) var hasAuthor:Bool = false

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasId {
      try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
    }
    if hasTitle {
      try codedOutputStream.writeString(fieldNumber: 2, value:title)
    }
    if hasAuthor {
      try codedOutputStream.writeString(fieldNumber: 3, value:author)
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(fieldNumber: 1)
    }
    if hasTitle {
      serialize_size += title.computeStringSize(fieldNumber: 2)
    }
    if hasAuthor {
      serialize_size += author.computeStringSize(fieldNumber: 3)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> BookInfo.Builder {
    return BookInfo.classBuilder() as! BookInfo.Builder
  }
  public func getBuilder() -> BookInfo.Builder {
    return classBuilder() as! BookInfo.Builder
  }
  override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return BookInfo.Builder()
  }
  override public func classBuilder() -> ProtocolBuffersMessageBuilder {
    return BookInfo.Builder()
  }
  public func toBuilder() throws -> BookInfo.Builder {
    return try BookInfo.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:BookInfo) throws -> BookInfo.Builder {
    return try BookInfo.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,Any> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
    if hasId {
      jsonMap["id"] = "\(id)"
    }
    if hasTitle {
      jsonMap["title"] = title
    }
    if hasAuthor {
      jsonMap["author"] = author
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,Any>) throws -> BookInfo {
    return try BookInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> BookInfo {
    return try BookInfo.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasTitle {
      output += "\(indent) title: \(title) \n"
    }
    if hasAuthor {
      output += "\(indent) author: \(author) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasTitle {
             hashCode = (hashCode &* 31) &+ title.hashValue
          }
          if hasAuthor {
             hashCode = (hashCode &* 31) &+ author.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "BookInfo"
  }
  override public func className() -> String {
      return "BookInfo"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:BookInfo = BookInfo()
    public func getMessage() -> BookInfo {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    @discardableResult
    public func setId(_ value:Int64) -> BookInfo.Builder {
      self.id = value
      return self
    }
    @discardableResult
    public func clearId() -> BookInfo.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var title:String {
         get {
              return builderResult.title
         }
         set (value) {
             builderResult.hasTitle = true
             builderResult.title = value
         }
    }
    public var hasTitle:Bool {
         get {
              return builderResult.hasTitle
         }
    }
    @discardableResult
    public func setTitle(_ value:String) -> BookInfo.Builder {
      self.title = value
      return self
    }
    @discardableResult
    public func clearTitle() -> BookInfo.Builder{
         builderResult.hasTitle = false
         builderResult.title = ""
         return self
    }
    public var author:String {
         get {
              return builderResult.author
         }
         set (value) {
             builderResult.hasAuthor = true
             builderResult.author = value
         }
    }
    public var hasAuthor:Bool {
         get {
              return builderResult.hasAuthor
         }
    }
    @discardableResult
    public func setAuthor(_ value:String) -> BookInfo.Builder {
      self.author = value
      return self
    }
    @discardableResult
    public func clearAuthor() -> BookInfo.Builder{
         builderResult.hasAuthor = false
         builderResult.author = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    @discardableResult
    override public func clear() -> BookInfo.Builder {
      builderResult = BookInfo()
      return self
    }
    override public func clone() throws -> BookInfo.Builder {
      return try BookInfo.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> BookInfo {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> BookInfo {
      let returnMe:BookInfo = builderResult
      return returnMe
    }
    @discardableResult
    public func mergeFrom(other:BookInfo) throws -> BookInfo.Builder {
      if other == BookInfo() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasTitle {
           title = other.title
      }
      if other.hasAuthor {
           author = other.author
      }
      try merge(unknownField: other.unknownFields)
      return self
    }
    @discardableResult
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> BookInfo.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    @discardableResult
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BookInfo.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          id = try codedInputStream.readInt64()

        case 18:
          title = try codedInputStream.readString()

        case 26:
          author = try codedInputStream.readString()

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> BookInfo.Builder {
      let resultDecodedBuilder = BookInfo.Builder()
      if let jsonValueId = jsonMap["id"] as? String {
        resultDecodedBuilder.id = Int64(jsonValueId)!
      } else if let jsonValueId = jsonMap["id"] as? Int {
        resultDecodedBuilder.id = Int64(jsonValueId)
      }
      if let jsonValueTitle = jsonMap["title"] as? String {
        resultDecodedBuilder.title = jsonValueTitle
      }
      if let jsonValueAuthor = jsonMap["author"] as? String {
        resultDecodedBuilder.author = jsonValueAuthor
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> BookInfo.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try BookInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

final public class MyLibrary : GeneratedMessage {

  public static func == (lhs: MyLibrary, rhs: MyLibrary) -> Bool {
    if (lhs === rhs) {
      return true
    }
    var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
    fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
    fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
    fieldCheck = fieldCheck && (lhs.books == rhs.books)
    fieldCheck = fieldCheck && (lhs.hasKeys == rhs.hasKeys) && (!lhs.hasKeys || lhs.keys == rhs.keys)
    fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
    return fieldCheck
  }



  //Nested type declaration start

    final public class KeysEntry : GeneratedMessage {

      public static func == (lhs: MyLibrary.KeysEntry, rhs: MyLibrary.KeysEntry) -> Bool {
        if (lhs === rhs) {
          return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
      }

      public fileprivate(set) var key:String = ""
      public fileprivate(set) var hasKey:Bool = false

      public fileprivate(set) var value:String = ""
      public fileprivate(set) var hasValue:Bool = false

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
          try codedOutputStream.writeString(fieldNumber: 1, value:key)
        }
        if hasValue {
          try codedOutputStream.writeString(fieldNumber: 2, value:value)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
      }
      override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
          serialize_size += key.computeStringSize(fieldNumber: 1)
        }
        if hasValue {
          serialize_size += value.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
      }
      public class func getBuilder() -> MyLibrary.KeysEntry.Builder {
        return MyLibrary.KeysEntry.classBuilder() as! MyLibrary.KeysEntry.Builder
      }
      public func getBuilder() -> MyLibrary.KeysEntry.Builder {
        return classBuilder() as! MyLibrary.KeysEntry.Builder
      }
      override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MyLibrary.KeysEntry.Builder()
      }
      override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return MyLibrary.KeysEntry.Builder()
      }
      public func toBuilder() throws -> MyLibrary.KeysEntry.Builder {
        return try MyLibrary.KeysEntry.builderWithPrototype(prototype:self)
      }
      public class func builderWithPrototype(prototype:MyLibrary.KeysEntry) throws -> MyLibrary.KeysEntry.Builder {
        return try MyLibrary.KeysEntry.Builder().mergeFrom(other:prototype)
      }
      override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
          jsonMap["key"] = key
        }
        if hasValue {
          jsonMap["value"] = value
        }
        return jsonMap
      }
      override class public func decode(jsonMap:Dictionary<String,Any>) throws -> MyLibrary.KeysEntry {
        return try MyLibrary.KeysEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
      }
      override class public func fromJSON(data:Data) throws -> MyLibrary.KeysEntry {
        return try MyLibrary.KeysEntry.Builder.fromJSONToBuilder(data:data).build()
      }
      override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
          output += "\(indent) key: \(key) \n"
        }
        if hasValue {
          output += "\(indent) value: \(value) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasKey {
                 hashCode = (hashCode &* 31) &+ key.hashValue
              }
              if hasValue {
                 hashCode = (hashCode &* 31) &+ value.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "MyLibrary.KeysEntry"
      }
      override public func className() -> String {
          return "MyLibrary.KeysEntry"
      }
      //Meta information declaration end

      final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:MyLibrary.KeysEntry = MyLibrary.KeysEntry()
        public func getMessage() -> MyLibrary.KeysEntry {
            return builderResult
        }

        required override public init () {
           super.init()
        }
        public var key:String {
             get {
                  return builderResult.key
             }
             set (value) {
                 builderResult.hasKey = true
                 builderResult.key = value
             }
        }
        public var hasKey:Bool {
             get {
                  return builderResult.hasKey
             }
        }
        @discardableResult
        public func setKey(_ value:String) -> MyLibrary.KeysEntry.Builder {
          self.key = value
          return self
        }
        @discardableResult
        public func clearKey() -> MyLibrary.KeysEntry.Builder{
             builderResult.hasKey = false
             builderResult.key = ""
             return self
        }
        public var value:String {
             get {
                  return builderResult.value
             }
             set (value) {
                 builderResult.hasValue = true
                 builderResult.value = value
             }
        }
        public var hasValue:Bool {
             get {
                  return builderResult.hasValue
             }
        }
        @discardableResult
        public func setValue(_ value:String) -> MyLibrary.KeysEntry.Builder {
          self.value = value
          return self
        }
        @discardableResult
        public func clearValue() -> MyLibrary.KeysEntry.Builder{
             builderResult.hasValue = false
             builderResult.value = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        @discardableResult
        override public func clear() -> MyLibrary.KeysEntry.Builder {
          builderResult = MyLibrary.KeysEntry()
          return self
        }
        override public func clone() throws -> MyLibrary.KeysEntry.Builder {
          return try MyLibrary.KeysEntry.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> MyLibrary.KeysEntry {
             try checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> MyLibrary.KeysEntry {
          let returnMe:MyLibrary.KeysEntry = builderResult
          return returnMe
        }
        @discardableResult
        public func mergeFrom(other:MyLibrary.KeysEntry) throws -> MyLibrary.KeysEntry.Builder {
          if other == MyLibrary.KeysEntry() {
           return self
          }
          if other.hasKey {
               key = other.key
          }
          if other.hasValue {
               value = other.value
          }
          try merge(unknownField: other.unknownFields)
          return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> MyLibrary.KeysEntry.Builder {
             return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary.KeysEntry.Builder {
          let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
          while (true) {
            let protobufTag = try codedInputStream.readTag()
            switch protobufTag {
            case 0: 
              self.unknownFields = try unknownFieldsBuilder.build()
              return self

            case 10:
              key = try codedInputStream.readString()

            case 18:
              value = try codedInputStream.readString()

            default:
              if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                 unknownFields = try unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> MyLibrary.KeysEntry.Builder {
          let resultDecodedBuilder = MyLibrary.KeysEntry.Builder()
          if let jsonValueKey = jsonMap["key"] as? String {
            resultDecodedBuilder.key = jsonValueKey
          }
          if let jsonValueValue = jsonMap["value"] as? String {
            resultDecodedBuilder.value = jsonValueValue
          }
          return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> MyLibrary.KeysEntry.Builder {
          let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
          guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
          }
          return try MyLibrary.KeysEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
      }

    }

  //Nested type declaration end

  public fileprivate(set) var id:Int64 = Int64(0)
  public fileprivate(set) var hasId:Bool = false

  public fileprivate(set) var name:String = ""
  public fileprivate(set) var hasName:Bool = false

  public fileprivate(set) var books:Array<BookInfo>  = Array<BookInfo>()
  public fileprivate(set) var keys:Dictionary<String,String> = Dictionary<String,String>()

  public fileprivate(set) var hasKeys:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeTo(codedOutputStream: CodedOutputStream) throws {
    if hasId {
      try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
    }
    if hasName {
      try codedOutputStream.writeString(fieldNumber: 2, value:name)
    }
    for oneElementBooks in books {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementBooks)
    }
    if hasKeys {
        for (keyKeys, valueKeys) in keys {
            let valueOfKeys = try! MyLibrary.KeysEntry.Builder().setKey(keyKeys).setValue(valueKeys).build()
            try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfKeys)
        }
    }
    try unknownFields.writeTo(codedOutputStream: codedOutputStream)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(fieldNumber: 1)
    }
    if hasName {
      serialize_size += name.computeStringSize(fieldNumber: 2)
    }
    for oneElementBooks in books {
        serialize_size += oneElementBooks.computeMessageSize(fieldNumber: 3)
    }
    if hasKeys {
        for (keyKeys, valueKeys) in keys {
            let valueOfKeys = try! MyLibrary.KeysEntry.Builder().setKey(keyKeys).setValue(valueKeys).build()
            serialize_size += valueOfKeys.computeMessageSize(fieldNumber: 4)
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func getBuilder() -> MyLibrary.Builder {
    return MyLibrary.classBuilder() as! MyLibrary.Builder
  }
  public func getBuilder() -> MyLibrary.Builder {
    return classBuilder() as! MyLibrary.Builder
  }
  override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
    return MyLibrary.Builder()
  }
  override public func classBuilder() -> ProtocolBuffersMessageBuilder {
    return MyLibrary.Builder()
  }
  public func toBuilder() throws -> MyLibrary.Builder {
    return try MyLibrary.builderWithPrototype(prototype:self)
  }
  public class func builderWithPrototype(prototype:MyLibrary) throws -> MyLibrary.Builder {
    return try MyLibrary.Builder().mergeFrom(other:prototype)
  }
  override public func encode() throws -> Dictionary<String,Any> {
    guard isInitialized() else {
      throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
    }

    var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
    if hasId {
      jsonMap["id"] = "\(id)"
    }
    if hasName {
      jsonMap["name"] = name
    }
    if !books.isEmpty {
      var jsonArrayBooks:Array<Dictionary<String,Any>> = []
        for oneValueBooks in books {
          let ecodedMessageBooks = try oneValueBooks.encode()
          jsonArrayBooks.append(ecodedMessageBooks)
        }
      jsonMap["books"] = jsonArrayBooks
    }
    if hasKeys {
        var mapKeys = Dictionary<String, String>()
        for (keyKeys, valueKeys) in keys {
            mapKeys["\(keyKeys)"] = valueKeys
        }
        jsonMap["keys"] = mapKeys
    }
    return jsonMap
  }
  override class public func decode(jsonMap:Dictionary<String,Any>) throws -> MyLibrary {
    return try MyLibrary.Builder.decodeToBuilder(jsonMap:jsonMap).build()
  }
  override class public func fromJSON(data:Data) throws -> MyLibrary {
    return try MyLibrary.Builder.fromJSONToBuilder(data:data).build()
  }
  override public func getDescription(indent:String) throws -> String {
    var output = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    var booksElementIndex:Int = 0
    for oneElementBooks in books {
        output += "\(indent) books[\(booksElementIndex)] {\n"
        output += try oneElementBooks.getDescription(indent: "\(indent)  ")
        output += "\(indent)}\n"
        booksElementIndex += 1
    }
    if hasKeys {
      output += "\(indent) keys: \(keys) \n"
    }
    output += unknownFields.getDescription(indent: indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          for oneElementBooks in books {
              hashCode = (hashCode &* 31) &+ oneElementBooks.hashValue
          }
          if hasKeys {
              for (keyKeys, valueKeys) in keys {
                  hashCode = (hashCode &* 31) &+ keyKeys.hashValue
                  hashCode = (hashCode &* 31) &+ valueKeys.hashValue
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "MyLibrary"
  }
  override public func className() -> String {
      return "MyLibrary"
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    fileprivate var builderResult:MyLibrary = MyLibrary()
    public func getMessage() -> MyLibrary {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    @discardableResult
    public func setId(_ value:Int64) -> MyLibrary.Builder {
      self.id = value
      return self
    }
    @discardableResult
    public func clearId() -> MyLibrary.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    @discardableResult
    public func setName(_ value:String) -> MyLibrary.Builder {
      self.name = value
      return self
    }
    @discardableResult
    public func clearName() -> MyLibrary.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var books:Array<BookInfo> {
         get {
             return builderResult.books
         }
         set (value) {
             builderResult.books = value
         }
    }
    @discardableResult
    public func setBooks(_ value:Array<BookInfo>) -> MyLibrary.Builder {
      self.books = value
      return self
    }
    @discardableResult
    public func clearBooks() -> MyLibrary.Builder {
      builderResult.books.removeAll(keepingCapacity: false)
      return self
    }
    public var hasKeys:Bool {
         get {
              return builderResult.hasKeys
         }
    }
    public var keys:Dictionary<String,String> {
         get {
              return builderResult.keys
         }
         set (value) {
             builderResult.hasKeys = true
             builderResult.keys = value
         }
    }
    @discardableResult
    public func setKeys(_ value:Dictionary<String,String>) -> MyLibrary.Builder {
      self.keys = value
      return self
    }
    @discardableResult
    public func clearKeys() -> MyLibrary.Builder{
         builderResult.hasKeys = false
         builderResult.keys = Dictionary<String,String>()
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    @discardableResult
    override public func clear() -> MyLibrary.Builder {
      builderResult = MyLibrary()
      return self
    }
    override public func clone() throws -> MyLibrary.Builder {
      return try MyLibrary.builderWithPrototype(prototype:builderResult)
    }
    override public func build() throws -> MyLibrary {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> MyLibrary {
      let returnMe:MyLibrary = builderResult
      return returnMe
    }
    @discardableResult
    public func mergeFrom(other:MyLibrary) throws -> MyLibrary.Builder {
      if other == MyLibrary() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasName {
           name = other.name
      }
      if !other.books.isEmpty  {
         builderResult.books += other.books
      }
      if other.hasKeys {
           keys = other.keys
      }
      try merge(unknownField: other.unknownFields)
      return self
    }
    @discardableResult
    override public func mergeFrom(codedInputStream: CodedInputStream) throws -> MyLibrary.Builder {
         return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
    }
    @discardableResult
    override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
      while (true) {
        let protobufTag = try codedInputStream.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8:
          id = try codedInputStream.readInt64()

        case 18:
          name = try codedInputStream.readString()

        case 26:
          let subBuilder = BookInfo.Builder()
          try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
          books.append(subBuilder.buildPartial())

        case 34:
          let subBuilder = MyLibrary.KeysEntry.Builder()
          try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
          let buildOfKeys = subBuilder.buildPartial()
          keys[buildOfKeys.key] = buildOfKeys.value

        default:
          if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
    class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> MyLibrary.Builder {
      let resultDecodedBuilder = MyLibrary.Builder()
      if let jsonValueId = jsonMap["id"] as? String {
        resultDecodedBuilder.id = Int64(jsonValueId)!
      } else if let jsonValueId = jsonMap["id"] as? Int {
        resultDecodedBuilder.id = Int64(jsonValueId)
      }
      if let jsonValueName = jsonMap["name"] as? String {
        resultDecodedBuilder.name = jsonValueName
      }
      if let jsonValueBooks = jsonMap["books"] as? Array<Dictionary<String,Any>> {
        var jsonArrayBooks:Array<BookInfo> = []
        for oneValueBooks in jsonValueBooks {
          let messageFromStringBooks = try BookInfo.Builder.decodeToBuilder(jsonMap:oneValueBooks).build()

          jsonArrayBooks.append(messageFromStringBooks)
        }
        resultDecodedBuilder.books = jsonArrayBooks
      }
      if let jsonValueKeys = jsonMap["keys"] as? Dictionary<String, String> {
          var mapKeys = Dictionary<String, String>()
          for (keyKeys, valueKeys) in jsonValueKeys {
              guard let keyFromKeys = String(keyKeys) else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
              }
              mapKeys[keyFromKeys] = valueKeys
          }
          resultDecodedBuilder.keys = mapKeys
      }
      return resultDecodedBuilder
    }
    override class public func fromJSONToBuilder(data:Data) throws -> MyLibrary.Builder {
      let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
      guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
      }
      return try MyLibrary.Builder.decodeToBuilder(jsonMap:jsDataCast)
    }
  }

}

extension BookInfo: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<BookInfo> {
    var mergedArray = Array<BookInfo>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> BookInfo? {
    return try BookInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(data: data, extensionRegistry:DataModelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> BookInfo {
    return try BookInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension MyLibrary: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<MyLibrary> {
    var mergedArray = Array<MyLibrary>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> MyLibrary? {
    return try MyLibrary.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(data: data, extensionRegistry:DataModelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary {
    return try MyLibrary.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension MyLibrary.KeysEntry: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<MyLibrary.KeysEntry> {
    var mergedArray = Array<MyLibrary.KeysEntry>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> MyLibrary.KeysEntry? {
    return try MyLibrary.KeysEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(data: data, extensionRegistry:DataModelRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> MyLibrary.KeysEntry {
    return try MyLibrary.KeysEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
